## OS-第七章-内存管理

## 1. 内存管理需求

### 1.1. 术语

页框（帧frame）：一个固定长度的**内存块**。



页（page）：一个固定长度的**数据块**（程序代码/数据），平时存储在二级存储器（磁盘）。

- 运行时，复制到一个内存**页框**中（页式）。**页**与**页框**大小相等。



段（segment）：一个变长的数据块，平时存储在二级存储器。

- 运行时，整段加载到一个内存区（段式）。
- 运行时，将一段分成多页，分别加载到多个页框（段页式）。

## 2. 内存分区

管理方式有3种：

- 分区（固定/动态分区）：

  属于**连续分配**方式，为一个用户分配一个连续的内存空间

- 分页（简单分页/虚拟内存分页）：离散分配

- 分段（简单分段/虚拟内存分段）：离散分配

### 2.1.  固定分区

**方式**：内存划成若干分区，并排成一个分区说明表。建立后分区大小、数量、边界**不再变化**。

**分配**：为进程分配一个满足长度要求的**最小空闲区**

**特性**：

- 优点：分配回收容易
- 缺点：限制了进程数量和最大长度，**易产生（区内）内碎片**，内存利用率低

![](http://img.doze9097.top//20200602151010.png)

### 2.2. 动态分区

**方式**：从可用内存中，划出进程所需要容量的一块**连续**区域进行分配，其余部分作为一个新空闲区。

**回收**：运行完后，若与其它空闲区相邻则合并。

**特性**：

- 缺点：**易产生（区间）外碎片**

**压缩**：空闲分区向前移动

> 碎片向内存一端移动，使碎片在另一端合成大空闲区。费时，需动态重定位
>
> 为了减少碎片：系统设置一个最小长度size，若产生的新空闲区小于size，则将整个空闲区分配而不划分

![](http://img.doze9097.top//20200602151423.png)

### 2.3. 动态分区的分配策略

1. **首次适配**（First Fit）：

   空闲区按照起始地址递增的顺序排列。

   **分配**：从链首向后找到第一个满足要求的空闲区划分。‘

   **特性**：低地址留有许多碎片，高地址留有大空闲区。

   ![](http://img.doze9097.top//20200602151122.png)

   ---

2. **下次适配**（Next Fit）：

   空闲区按照起始地址递增的顺序排列。

   **分配**：从上次扫描结束的地方继续查找。

   **特性**：平均查找时间缩短，空间利用比首次适配（FF）均衡。

   ![](http://img.doze9097.top//20200602151303.png)

   ---

3. **最佳适配**（Best Fit）：

   空闲区按分区大小**递增**顺序排列。

   **分配**：从链首开始查找第一个满足进程要求大小的空闲区

   **特性**：链首部碎片多，查找费时。回收合并复杂（合并后需要排列）。

   ![](http://img.doze9097.top//20200602151821.png)

   ---

4. **最差适配**（Worst Fit）：

   空闲区按分区大小**递减**顺序排列。

   **分配**：从链首查找，第一个若不能满足则分配失败，否则从第一个分区分出要求的大小

   **特性**：小碎片少，最大空闲区不会很大

   ![](http://img.doze9097.top//20200602152031.png)

   ---

### 2.4 动态分区策略比较

- 内存分配：FF最快（不需要调整新分区位置）
- 内存回收：FF最佳（合并空闲区容易）
- NF比FF更均衡利用内存，但碎片分散，压缩次数多
- 查找最合适的空闲区：BF最快（碎片多，压缩最频繁；回收时，合并相邻空闲区可能要遍历空闲区链表。）

> BF性能通常最差。

### 2.5. 伙伴系统 ***

伙伴：两个相邻的帧块，每块相同。

伙伴系统：将更大的内存对半分裂为左伙伴、右伙伴。回收时，**对应伙伴都空闲则合并**。

![](http://img.doze9097.top//20200602152609.png)

### 2.6. 重定位

重定位：将**逻辑地址**转换成**物理地址**

> 逻辑地址：程序中引用的地址，从0开始’
>
> 物理地址：数据在内存单元中的地址

访问内存单元之前，将有关地址重定位

硬件支持：基址寄存器 和 界限寄存器

![](http://img.doze9097.top//20200602155757.png)**保护的实现**

存储保护：用两个寄存器标识合法访问地址范围

> - 采用 **基址+界限** ：最小合法地址 + 最大合法地址
> - 采用 **基址+限长** ：最小合法地址 + 长度

进程的这一对值作为限长，保存在各自的PCB中



### 3. 分页

### 3.1. 基本原理

为进程的多个**页离散地分配**内存帧

每个进程最后一页有**内碎片**。**无外碎片**，内存利用率高。

用32位作为例子：

![](http://img.doze9097.top//20200602160448.png)

### 3.2. 页表

页表：记录**进程的每个页**放在哪一个**内存帧**

> 注意区分进程页和内存页框（帧）

每个进程有一张自己的页表。

页表位于内存。

OS维护一个 **空闲页框列表** （常用 **位图** 表示）

![](http://img.doze9097.top//20200602160928.png)